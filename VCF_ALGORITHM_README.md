# VCF (Verified Continuous Forcing) 算法实现

## 算法概述

VCF 是五子棋AI中的核心算法，用于检测必赢的连续强制序列。该算法优先级如下：

1. **立即五连** - 最高优先级，直接赢
2. **VCF必赢** - 通过活四、双活三或连续冲四形成必赢
3. **活三/冲四防守** - 紧急防守敌方威胁
4. **强力防守** - 评估棋位的威胁值
5. **强势进攻** - 寻找进攻机会
6. **Alpha-Beta搜索** - 深层评估

## 核心函数

### find_vcf_winning_move()
检测AI是否存在必赢的第一步走法。

```c
Position find_vcf_winning_move(GameState *state, Player aiplayer, int depth)
```

**检测顺序：**
- 活四（两端开放的四）→ 立即返回必赢
- 双活三（两个不同方向的活三） → 立即返回必赢
- 单活三/冲四 → 进行深度VCF搜索

### vcf_search()
递归搜索VCF序列是否能保证AI必赢。

```c
int vcf_search(GameState *state, Player aiplayer, Player current_player, int depth)
```

**工作机制：**
- **当对手回合时** - 对手被迫防守AI的所有活三威胁
- **当AI回合时** - AI继续寻找能维持必赢的招式

## 必赢判定规则

1. **活四 = 必赢**
   - 形式：`_XXXX_`（两端开放）
   - 对手无法同时堵住两端

2. **双活三 = 必赢**
   - 两个不同方向都有活三
   - 对手只能防守一个，AI接下来必然形成活四

3. **连续冲四 = 必赢**
   - AI落子后形成冲四，对手被迫防守
   - 对手防守后，AI继续形成新的威胁
   - 最终形成必赢局面

## 示例

### 活四的必赢
```
原局面：
  F G H I J K
8 ◎ ● ◎ ◎ ◎
7 ● ◎ ◎ ◎ ●

AI在G8落子 → _XXXX_ 形式活四 → 必赢
```

### 双活三的必赢
```
AI同时在两个方向形成活三：
- 横向：_XXX_ 
- 纵向：_XXX_

对手防守横向后，AI继续纵向成四 → 对手无法两个都防守
```

## 性能优化

1. **搜索深度限制** - 最多8层搜索，避免过度计算
2. **候选位置限制** - 每层最多检查20个候选位置
3. **时间限制** - 每步思考时间限制15秒
4. **提前返回** - 找到活四或双活三立即返回

## 输出示例

```
AI正在思考中
AI落子位置: H8 (VCF必赢)
AI Time: 0.25 seconds
```

## 与其他防守的关系

- **优先级高于** - 强力防守、Alpha-Beta搜索
- **优先级低于** - 立即五连、立即防守必输
- **补充机制** - 如果没有VCF必赢，则进行防守

## 调整参数

在 `ai.c` 中可以调整：

```c
#define SEARCH_DEPTH 10        // Alpha-Beta搜索深度
#define MAX_SCORE 1000000      // 最大评估分数
#define MIN_SCORE -1000000     // 最小评估分数
#define MaxCandidate 100       // 最大候选位置数
#define TIME_LIMIT 15.0        // 每步思考时间限制（秒）
```

## 未来优化方向

1. 实现更复杂的VCF变体（三元VCF、交叉VCF等）
2. 使用置换表（Transposition Table）缓存已搜索的局面
3. 实现更精细的搜索窗口优化
4. 增加开局库和残局库支持
